# 三次握手

+ 三次握手是指建立一个TCP连接时, 需要客户端和服务器总共发出三个包。主要是为了确认双方的收发能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。
+ 刚开始时客户端处于Closed状态, 服务端处于Listen状态
+ 第一次握手: 客户端向服务端发送一个SIN报文, 并指定客户端的初始化序列号ISN。此时客户端处于SYN_SEND状态。
    - 首部的同部位`SYN=1`,初始序号`seq=x`, SYN=1的报文段不能携带数据, 但是要消耗一个序号
+ 第二次握手: 服务器收到客户端发的SYN报文后, 会以自己的SYN报文作为应答, 并且也指定了自己的初始化序列号ISN.同时会把客户端的`ISN+1`作为ACK的值, 表示自己已经收到了客户端发送的SYN报文。此时服务端处于SYN_REVD状态
    - 报文段中 SYN=1, ACK=1, 确认号ack=x+1, 初始序号seq=y
+ 第三次握手: 客户端收到SYN报文之后, 会发送一个ACK报文, 也是一样把服务器的ISN+1作为ACK的值, 表示已经收到了服务端SYN报文, 此时客户端处于ESTABLISHED状态。服务器收到ACK报文之后, 也处于ESTABLISHED状态。此时双方的连接已经建立
+ 发送第一个SYN的一端将执行主动打开(active open), 接收这个SYN并发回下一个SYN的另一端执行被动打开(passive open)
+ webSocket中执行connect()将触发三次握手

## 为什么需要三次握手, 两次握手行不行

### 首先要明白三次握手的目的

+ 第一次握手, 客户端发包, 服务端收到了, 此时是为了确认客户端的发送能力和服务端的接收能力正常
+ 第二次握手, 服务端发包, 客户端收到了, 此时为了确认客户端的接收能力和服务端的发送能力正常。但是服务端并不能确认客户端的接收能力正常
+ 第三次握手, 客户端发包, 服务端收到了, 这样才能够让服务端也得出结论: 客户端的收发能力正常，服务端的收发能力正常
+ 因此需要三次握手

### 如果改成两次

可能会出现客户端发包, 但是这个包丢失了, 于是客户端再一次重传发起连接请求。 后来收到了建立连接, 数据传完了释放连接, 在这个过程中, 客户端一共发了两个包, 一个丢失, 一个正常抵达, 但是没有抵达的那个包因为延迟问题, 在释放连接之后, 又抵达了服务端, 这样服务端就会误认为是客户端发起了连接请求, 于是返回一个SYN报文, 确认建立连接。然后客户端又忽略服务器的确认连接报文, 不发数据, 这样服务端就会一直重发, 发出大量的SYN报文, 浪费资源

## 什么是半连接队列

+ 服务器第一次收到SYN包之后, 就会处于SYN_REVD状态, 此时双方还没有建立其连接, 服务器会把此种状态下请求连接放在一个队列里, 这就是半连接队列
+ 三次握手完成建立起的连接会放在另一个队列里，叫全连接队列。如果队列满了, 可能会出现丢包现象
+ SYN-ACK重传次数: 有一个最大上限的设置, 超过上限值就将连接从半连接队列中移除, 每一次重传间隔时间是不一定的, 一般是程指数增长

## ISN是固定的吗

+ 当一端为建立连接而发送他的SYN时, 它为连接选择一个初始序号。ISN随时间而变化, 因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器, 每4ms加一。这样选择序号的目的在于防止网络中被延迟的分组以后又被传送, 而导致某个连接的一方对它做出误解
+ 三次握手的其中一个重要的功能就是双方交换各自的ISN，以便让对方知道自己接下来接收数据的时候如何按照序列化去组装数据, 如果ISN固定，很容易被黑客猜到接下来的确认号, 因此ISN是动态生成的

## 三次握手可以携带数据吗

+ 第三次可以携带数据, 前两次不行
+ 第三次握手时,客户端已经处于ESTABLESHED状态，对他来说连接已经建立起来了, 并且也知道服务器的收发能力正常, 因此是可以携带数据的

## SYN攻击是什么
服务端的资源分配在于第二次握手,而客户端的资源是第三次握手完成后才分配的, 所以服务端容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址, 并向Server不停的发送SYN包, Server会回复包, 并等到Client确认, 由于源地址其实并不存在, 因此Server就会不停的重发, 直到超时, 这些伪造的SYN包将长时间占据半连接队列, 导致正常的SYN请求因为队满被放弃，从而引起网络拥塞, 甚至瘫痪.

+ 常见防御手段:
    - 缩短超时时间
    - 增加最大半连接数
    - 过滤网关防护
    - SYN cookies技术