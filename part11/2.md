# 解析

网络请求完成后，接下来就是解析算法阶段。如果完成网络响应，响应头中Content-type的值时text/html，那么接下来就是浏览器的解析和渲染工作了。

解析部分分为：

1. 构建DOM树

2. 样式计算

3. 生成布局树

## 构建DOM树

由于浏览器无法直接理解HTML字符串，因此要将一系列的字节流转换成一种有意义且方便操作的数据结构，这就是DOM树。

DOM树本质上是一个以document为根节点的多叉树

而HTML是一种非`上下文无关文法`，也就是说HTML的解析是和他的上下文挂钩的，一般的编程语言都是`上下文无关文法`, 但是HTML不一样，也就是它非`上下文无关`的特性决定了HTML Parser要另辟蹊径。

### 解析算法

H5详细说了解析算法，分两个阶段：

1. 标记化
2. 建树

对应的两个过程就是词法分析和语法分析

#### 标记算法：

这个算法就是输入HTML文本，输出HTML标记，也就是`标记生成器`。其中运用有限的自动状态机来完成。即在当前状态下，接收一个或多个字符串，就会更新到下一个状态。

如

```
<HTML>
    <body>
        Hello World
    </body>
</HTML>
```

当遇到`<`的时候，状态就标记为`打开`，然后接收[a-z]的字符，会进入`标记名称状态`，并且一直保持，直到遇到`>`，表示标记名称记录完成，这时就变成`数据状态`,

接下来遇到body标签做一样的事情

此时 html和body就标记完了

接下来从body中的`>`开始进入`数据状态`, 之后保持这个状态接收完后面的字符 `Hello World`

而后接收</body>中的`<`就标记为打开， 遇到`/`就创建一个`end tag`的token, 随后进入`标记名称状态`, 直到遇到`>`就回到`数据状态`, </html>同样如此

#### 建树算法：

由于DOM树是一个以document为根节点的多叉树，因此解析器会创建一个document对象，标记生成器会把每一个标记信息发送给建树器。建树器接收到相应的标记时，创建对应的DOM对象。之后会做两件事：

1. 将DOM对象加入到DOM树中
2. 将对应标记压如存放开放（对闭合标签对应）元素的栈中

还是以上面那段例子说：

首选状态时`初始化`状态，接收到标记生成器传来的html标签后状态变成`before html`状态, 同时创建一个`HTMLHtmlElement`的DOM元素，将其加入到document根对象上，并进行压栈操作

接着状态变成 `before head` 状态，次数标记生成器那边传来body，表示并没有head，此时建树器会自动创建一个`HTMLHeadElement`并将其加入到DOM树中。

现在进入`in head`状态，然后直接跳过，直接到`after head`状态。

标记器传来body标记，创建`HTMLBodyElement`, 插入到DOM树中，同时压入开放标记栈

接着状态变成`in body`，而后接收后面一系列字符串，当接收到第一个时就会创建一个`Text`标签并加入到DOM树中的body下面，随着不断的接收字符串，都将他们附在Text节点上

现在标记生成器传来一个`body`结束标记，进入到`after body`状态

标记生成器最后传来html结束标记，进入`after after body`表示解析过程到此结束

### 容错机制

说到H5的规范，就不得不说他强大的容错机制(宽容策略)

下面是webkit经典容错实例

1. 使用</br>而不是使用<br>的标签全部都会换成<br>

2. 表格离散，table中嵌套的table标签，会将内部的table以及其内部所有节点一起，渲染到和他外面的table同级。

3. 表单元素嵌套，直接忽略内部的form，将form结束标签后的内容全部拿到第一个form外面去

## 样式计算

关于CSS样式，来源有三种：

1. 通过link标签引用
2. style标签中的样式
3. 内联样式

### 格式化样式表

首先，浏览器无法直接识别CSS样式文本，因此渲染引擎收到CSS文件后第一件事就是将其转化为一个结构化的对象即styleSheets

在浏览器控制塔能够通过document.style.Sheets来查看最终的结构，当然这里面包含了以上三种来源为后面的样式操作提供基础。

### 标准化样式属性

有一些CSS样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将他们标准化，比如 em -> px, red -> #ff0000, bold -> 700等

### 计算每个节点的具体样式

样式已经被格式化和标准化，接下来就可以计算每个节点的具体样式信息了。其实计算的方式也不复杂，主要是两个规则： 继承和层叠

每个子节点都会默认继承父节点的样式属性，如果父节点中没有，就会采用浏览器默认样式，也叫userAgent样式

而后是层叠规则， CSS最大的特点在于层叠性，也就是最终的样式取决于各个属性共同作用的结果，甚至有较多诡异的层叠现象，不过值得注意的是，在计算完样式后，所有的样式的值，都会挂载到window.computedStyle中，也可以通过JS来获取计算后的样式，很方便。

## 生成布局树

现在已经生成了DOM树和DOM样式， 接下来要做的就是通过浏览器的布局系统，确定元素的位置，也就是要生成一棵布局树。

大致过程如下：
1. 遍历生成的DOM树节点，并把他们添加到布局树中
2. 计算布局树节点的坐标位置

注： 布局树包含可见元素，对于head标签设置了display：none的元素将不会放到布局树中

有人说会生成Render Tree(渲染树)， 但这已经是16年之前的事情了，现在的chrome做了大量的重构，已经没有了Render Tree的过程，但是布局树的信息非常完善，他完全拥有Render Tree的功能
