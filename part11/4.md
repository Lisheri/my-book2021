# 从输入URL到页面呈现

首先第一步要构建网络请求，写入网络的是请求行，说明了请求方式， 请求的路径和http协议版本。接下来要查找强缓存，如果命中了缓存则直接使用缓存数据并且跳过网络响应阶段进入后面的阶段。如果没有命中强缓存，则进入DNS域名解析，因为TCP的连接需要的是对应的IP地址，因此需要解析出对应的IP地址。当然如果解析过一次了，浏览器提供了DNS数据缓存，就不会解析而是直接走缓存了。解析完成后就会建立TCP/IP连接。TCP建立连接的过程一共需要放三个包，因此又叫三次握手。建立完成后，就开始发送HTTP请求，一个HTTP请求由请求行，请求头和请求体构成。请求行规定了请求方式，请求的路径和HTTP协议版本。请求头中含有和请求相关的信息，比如Cache-Control，if-Modify-Since, if-None-Match，Content-Type，cookie，Token，Connection，Accept-Coding等。最后是请求体，请求体只在Post请求下才有，常见的是表单提交。至此，网络请求完成。

上述响应完成后，响应头中的Content-Type的值时text/html，那么接下来就进入了浏览器的解析和渲染工作了。首先是goujianDOM树，然后计算样式，最后生成布局树。由于浏览器无法直接理解HTML字符串，因此要将一系列的字节流转换成一种有意义且方便操作的数据结构，也就是DOM树。DOM树本质上是一个以document为根节点的多叉树。解析算法阶段分两个阶段，第一个是标记化，就是对输入的HTML文本做标记，然后输出HTML标记，也叫标记生成器。运用有限的自动状态机来完成。即在当前状态下，接收一个或多个字符串，就会更新到下一个状态。第二个就是建树， DOM树是一个以document为根节点的多叉树，因此解析器会创建一个document对象，标记生成器会把每一个标记信息发送给建树器。建树器收到相应的标记时，创建对应的DOM对象，然后会做两件事，首先将DOM对象加入到DOM树中，然后将对应的标记压入存放开放（与闭合标签对应）元素的栈中，完成建树。同时H5还有容错机制，各个浏览器的容错机制有点不同。

解析完成后就是样式计算，由于CSS的来源有三种，一个是link标签引用，一个是style标签，一个是内联样式。样式计算首先要格式化样式表，浏览器不能直接识别CSS样式文本，因此渲染引擎接收到CSS文件后第一件事就是将他们转换为一个结构化的对象————styleSheets，然后就可以通过document.style.Sheets来查看最终的结构，这里面包含了上述三个来源，直接为后面的样式操作提供基础。下一步时标准化样式属性，因为很多属性浏览器是不能识别的，需要转换为他可以识别的属性，比如rem->px等。之后就是计算每个节点的具体样式了，计算的方式并不复杂，主要是两个规则：继承和层叠。每个子节点会继承父节点的样式属性，如果没有，就采用浏览器默认样式，比如font-size等。而层叠规则是CSS最大的特点，也就是标签优先级。

最后要生成一棵布局树，在16年以后，chrome经过多次重构，已经不再使用渲染树了，但是布局树，兼容了渲染树所有的功能。在已经有了DOM树和DOM样式的情况下，接下来就是通过浏览器的布局系统，确认元素的位置，生成一棵布局树。分为两个步骤，第一个是遍历生成的DOM树节点，并把他们添加到布局树中，第二是计算布局树节点的坐标位置。(注: 对于header标签设置了display:none的元素不会放到布局树中)

有了布局树之后，最后一个大的步骤就是渲染，分为四个步骤，建立图层数，生成绘制表，生成图块并且栅格化，显示器显示内容。

首先要建立图层数，DOM节点有了，样式和位置信息也有了，但是还有一些复杂的场景比如说3d长，元素层叠上下文时如何控制显示和隐藏等问题。所以构建完布局树后，还需要对特定的节点分层，建立一棵图层树。图层树建立有两个情况，显示合成和隐式合成。显示合成主要是对拥有层叠上下文的节点做处理，主要是html根元素，普通元素的position属性不是static并且设置了z-index，元素的opacity不为1，元素的transform属性不是none，元素的filter属性不是none，元素的isolation值是isolate，will-change指定的属性值是上面任何一个。然后是需要剪裁的地方，都会产生显示合成。然后是隐式合成，隐式合成有危害，当层叠等级低的节点被提升为单独的图层后，所有层叠等级比他高的都会变成单独的图层。因此在一个大系统中，可能会出现一次增加上千个图层，大大增加内存压力，导致页面崩溃，这就是图层爆炸。

图层树建立完成后要生成一个绘制列表，接下来渲染引擎会将图层的绘制拆分为一个一个的绘制指令，比如，先画背景，在画边框等，然后将这些指令组合成一个待绘制列表，相当于给后面的绘制操作做了一个计划。之后就开始正式的绘制操作，在渲染进程中绘制操作是由专门的合成线程来完成的。在绘制列表准备完了之后，渲染现场的主线程会给合成线程发送commit信息，把绘制列表交给合成线程。接下来就是合成线程发挥的时候了，由于视口大小是固定的，页面非常大的时候，如果一口气渲染完就非常浪费性能，因此合成线程要做的第一件事就是将图层分块，块的大小并不大，一般是256 * 256 或者是512 * 512，这样可以大大加速首屏渲染。由于后面的数据要进入GPU内存，考虑到浏览器内存上传到GPU内存操作比较慢，即便是绘制一部分图块，因此chrome做了一个策略，就是合成图快的时候，只采用一个低分辨率的图，在首屏展示的时候只展示低分辨率的图片，然后继续合成操作，直到正常的图块绘制完成，就会替换当前低分辨率的图。

同时，在渲染进程中标专门维护了一个栅格化线程，负责将图块转换为位图数据。然后合成线程会选择视口附近的拖垮，把他交给栅格化线程池生成位图。生成位图的过程实际上都会使用GPU进行加速，生成的位图最后交给合成线程。

最后是显示器显示内容，栅格化完成后，合成线程会生成一个绘制指令，也就是`DrawQuad`，发给浏览器进程。浏览器进程中的viz组件接收到这个命令后，根据这个命令，把页面内容绘制到内存中，也就是生成页面，然后把这部分内存发给显卡。

无论是PC显示器还是手机屏幕，都有一个固定的刷新频率，一般是60HZ，也就是60帧，一秒刷新60次更新60张图片，一张图片停留的时间大概是16.7ms，每次更新的图片都来自于显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动在前缓冲区和后缓冲区之间切换，如此循环更新。所以当某个动画大量占据内存的时候，浏览器生成图片会变得非常慢，图像传送给显卡会不及时，而浏览器还是以不变的频率刷新，因此就会造成卡帧，也就是明显的掉帧。
