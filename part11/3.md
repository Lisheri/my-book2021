# 渲染

最后一个过程就是渲染，分为下面几个步骤：

1. 建立图层树
2. 生成绘制表
3. 生成图块并栅格化
4. 显示器显示内容

## 一、建立图层树

如果说DOM节点有了，样式和位置信息也有了，就可以开始绘制页面了，那就错了。还有一些复杂的场景，比如3d动画，3d场景如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等。

为了解释上述问题，浏览器在构建完布局树后，还会对特定的节点分层，建立一棵图层树(Layer Tree)

有两种情况: 显示合成和隐式合成

### 显示合成：

1. 拥有层叠上下文的节点
 + html根元素本身就具有层叠上下文
 + 普通元素设置position不为static并设置了z-index属性会产生层叠上下文
 + 元素的opacity的值不是1
 + 元素的transform属性不是none
 + 元素的filter值不是none
 + 元素的isolation值时isolate
 + will-change指定的属性值时上面任意一个

2. 需要剪裁的地方

如果一个div是100 *100，里面文字超出，就需要剪裁。若有滚动条，那么滚动条会单独提升一个图层。

### 隐式合成

简单的说就是层叠等级低的节点被提升为单独的图层后，那么所有层叠等级比他高的节点都会成为一个单独的图层

这个隐式合成其实有一个巨大的风险，如果在大型应用中，当一个z-index比较低的元素被提升为单独的图层后，层叠在它上面的元素流通都会被提升为单独的图层，可能会增加上千个图层，大大增加内存压力，甚至让页面崩溃，这就是图层爆炸

注：重绘时只会重绘节点本身，而不是整体重绘

## 二、生成绘制列表

接下来渲染引擎会将图层的绘制拆分为一个个绘制指令，比如，先画背景，再描边框等，然后将这些指令组合成一个待绘制列表，相当于给后面的绘制操作做了一个计划

## 三、生成图块和生成位图

现在开始绘制操作，实际上在 渲染进程中绘制操作是由专门的线程来完成的，这个线程叫合成线程。

绘制列表准备好之后，渲染进程的主线程会个合成线程发送commit信息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候了。

首先，考虑到视口只有那么大，当页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来的话是非常浪费性能的。因此，合成线程要做的第一件事就是将图层分块，这些块的大小一般不会很大，通常是256 * 256 或者是 512 * 512这个规格，这样可以大大加速页面的首屏展示。

因为后面的数据要进入GPU内存，考虑到浏览器内存上传到GPU内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量的时间。针对这个问题，chrome采用了一个策略：

在首次合成图块的时候，只采用一个低分辨率的图片，这样在首屏展示的时候只展示出低分辨率的图片，这时候继续合成操作，直到正常的图块内容绘制完成，会将当前分辨率的图块内容替换。这是chrome底层优化首屏展示的一个手段。

顺便说一点，渲染进程中专门维护了一个栅格化线程，也专门负责把图块转换为位图数据

然后合成线程会选择视口附近的图块，把他交给栅格化线程池生成位图。

生成位图的过程实际上都会使用GPU进行加速，生成的位图最后发给合成线程。

## 四、显示器显示内容

栅格化操作完成后， 合成线程会生成一个绘制指令，即`DrawQuad`并发给浏览器进程

浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存中，也就是生成页面，然后把这部分内存发给显卡。至于说为什么要发给显卡，就涉及到显示器对图像的显示原理了。

无论是PC显示器还是手机屏幕，都有一个固定的刷新频率，一般是60HZ，即60帧，也就是一秒刷新60次，更新60张图片，一张图片停留的时间大约是16.7ms。每次更新的图片都来自于显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。

所以当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会卡帧，也就是明显的掉帧。
