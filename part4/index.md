# v8垃圾回收机制

首先来说, v8对堆内存是存在限制的, 在64位系统下, 最多只能分配1.4个g的堆内存, 32位系统0.7个g,
对于栈内存来说, ESP指针下移, 上下文切换, 栈顶空间就被自动回收了

在js中, 所有的引用类型都是存储在堆中的, 比如创建一个对象, 就在堆中开辟一个内存区域, 不断的往里面写入成员, 那么堆的内存就越来越大, 让v8为他分配空间, 直到达到内存上限

设置内存上限的原因:
首先js是单线程, 意味着垃圾回收的时候, 其余逻辑都要暂停, 再次就是v8给的说明是, 在完全清空1.4G堆内存的情况下, 做一次垃圾回收需要50ms以上, 做一次非增量式回收, 甚至需要1s以上

当然, 堆内存的大小是可以调节的
```
// 新生代(单位是kb)
node --max-new -space-size = 2048 xxx.js
// 老生代(单位是mb)
node --max-old-space-size = 2048 xxx.js
```

js将堆内存分为两个部分
+ 新生代, 一般是临时分配的内存, 容量不大，存活时间短(上限是64位 32MB, 32位 16MB)
+ 老生代, 常驻内存, 存活时间久, 容量大

回收方式
+ 新生代
    - 将新生代一分为二, From表示正在使用的内存, to表示闲置的内存
    - 在进行垃圾回收的时候, v8将From部分的对象都检查一遍, 如果是存活的对象直接复制到to中(To中的内存是按顺序从头到尾放置的), 非存活对象直接回收
    - 当所有的存活对象都按顺序进入To中之后, 然后To和From身份对调, From中的内存被闲置, To中正在使用， 如此循环
    - 当然, 可能会出现存货对象在堆中分配不均匀的情况, 这就是所谓内存碎片, 需要使用一个算法对To中的内存进行整理(Scavenge算法), 也叫碎片整理
    - 新生代的劣势很明显, 就是只使用了一半的空间, 但是处理生命周期很短的对象, 这样的对象不多, 因此效率很高
+ 老生代
    - `晋升` 如果新生代中经过多次循环回收后, 依然还在From中存在, 那么就会将其移动到老生代中。 发生`晋升`的原因如下
        + 已经经历过一次Scavenge回收的对象
        + To(闲置)空间内存占用超过25%
    - 第一步, 进行标记-清除
        + 标记阶段: 遍历所有对象, 对他们做上标记, 然后对代码中`使用的变量`和`强引用`的变量取消标记, 剩下的都是要删除的变量
        + 清除阶段: 回收空间
    - 整理内存碎片, 在老生代中很暴力, 直接将存活对象往一端移动
+ 增量标记
    - 由于js是单线程, 因此垃圾回收的时候不可避免的会阻塞业务的进行, 如果老生代中回收任务很重, 耗时会非常恐怖, 严重影响性能, 为了避开这个问题, V8采用`增量标记`
    - `增量标记`: 也就是将一口气完成的标记任务, 分为一块一块的小块, 完成一小块标记就停一下去执行js逻辑, 然后在执行下面的部分, 如此循环下去, 直到标记阶段完成, 才进入清除阶段, 然后整理碎片