# Node中的Event Loop

Node中的Event Loop和浏览器中的有些许不同

Node中的事件循环分为六个部分，他们会按照顺序反复运行。每当进入某一个阶段的时候， 都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一阶段

![avatar](https://user-gold-cdn.xitu.io/2018/11/13/1670c3fe3f9a5e2b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 1.三大关键阶段

首先, 在Nodejs中有三个非常重要的阶段:

1.执行`定时器回调`的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout，setInterval。这个阶段暂且叫它`timer`。

2.轮询(就是上图中的poll)阶段。因为在Node代码中难免有异步操作，比如文件I/O, 网络I/O等，那么当这些异步操作做完了，就会来通知JS主线程, 就是通过'data'、'connect'等事件使得事件循环到达`poll`阶段。到达这个阶段后:

如果当前已经存在定时器，而且有定时器到时间了，就会拿出来执行，eventLoop回到timer阶段。

如果没有定时器，会查看回调函数队列。

+ 如果队列`不为空`, 拿出队列中的方法依次执行
+ 如果队列`为空`，检查是否有`setImmediate`的回调
    - 有则前往`check阶段`
    - `没有则继续等待`, 相当于阻塞一段时间(阻塞时间是有上限的), 等待callback函数加入队列，加入后立即执行，一段时间后`自动进入check阶段`

3.check阶段。这是一个比较简单的阶段，直接`执行setImmediate`的回调。

这三个阶段是一个循环的过程。不过现在的eventLoop并不完善。

## 完善eventLoop
首先, 当第一阶段结束后, 可能并不会立即等待到异步事件的响应, 这时候nodejs会进入到`I/O异常的回调阶段`。比如TCP链接遇到ECONNREFUSED(链接被服务器拒绝 connect refused)，就会在这个时候执行回调。

并且在check阶段结束后还会进入到`关闭事件的回调阶段`。如果一个socket或句柄(handle)被突然关闭，例如socket.destroy()，'close'事件的回调就会在这个阶段执行。

梳理一下, nodejs的eventloop分为以下几个阶段

+ 1.timer阶段
+ 2.I/O异常回调阶段
+ 3.空闲、预备状态(第2阶段结束, poll未触发之前)
+ 4.poll阶段
+ 5.check阶段
+ 6.关闭事件的回调阶段


## node版本

在node版本 >= 11和在11以下的表现不同。

在node版本 >= 11的时候，他和浏览器对于微任务和宏任务的表现是一致的。

但是在node版本 < 11 的时候， 对于定时器的处理是: 
`如果一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存起来， 直接去执行 新的定时器任务, 当新的定时器任务执行完后， 再一一执行 中途产生的微任务`

## nodejs和浏览器关于eventLoop的主要区别

两者最主要的区别在于浏览器中的微任务是在`每个相应的宏任务`中执行的，而nodejs中的微任务是在`不同阶段之间`执行的。

## process.nextTick

process.nextTick是一个独立于 eventLoop 的任务队列

在每个event Loop阶段完成后去检查这个队列, 如果里面有任务, 会让这部分任务 `优先于微任务` 执行。