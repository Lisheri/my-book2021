# 从缓存位置上区分

## Service Worker
+ `Service Worker` 是运行在浏览器背后的独立线程, 一般用以实现缓存功能，可以拦截请求, 因此必须使用HTTPS协议来保障安全.
+ 他与其他浏览器内建的缓存机制不同, 它支持我们自由控制缓存哪些文件, 如何匹配缓存, 如何读取缓存, 并且缓存是可持续性的
+ 在PWA这样的概念中, `Service Worker`是其中的核心实现者, 可用作离线消息推送, 这个功能就是通过缓存来实现的
+ 要注意的是, 当`Service Worker`没有命中缓存的时候, 会调用fetch函数获取数据, 也就是说如果`Service Worker`没有命中缓存, 会根据缓存优先级去查找数据。但是不管是从Memory Cache还是从请求中获取新的数据， 浏览器都会显示我们是从`Service Worker`中获取的。

## Memory Cache
+ `Memory Cache` 表示内存中的缓存, 主要包含的是当前页面中已经抓取的资源. 内存缓存读取比磁盘快, 但是在高效率读取的同时, 他的可持续性也非常短.会随着进程的释放而释放, 因此一旦我们关闭Tab页, 内存中的缓存也就释放了
+ 不能存储在计算机的内存中, 谷歌默认使用的堆内存大约在1.5个G, 不会给我们自由操作的空间
+ 内存缓存中有一个很重要的缓存资源是由preloader相关指令下载的资源。 他是常见优化手段之一, 可以一边解析js/css 一边请求下一个资源
+ 注意: 内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值, 同时资源的匹配也并非仅仅是对URL做匹配, 还可能对Content-type CORS等其他特征做校验

## Disk Cache
+ `Disk Cache` 是存储在硬盘中的缓存, 读取速度慢了点, 但是什么都可以存, 对比内存缓存就胜在存储时效性和容量大。 
+ 在浏览器缓存中, 磁盘缓存覆盖面最大，他会根据HTTP Header来判断哪些资源需要缓存, 哪些资源不需要请求直接使用, 哪些资源已经过期需要重新请求
+ 关于 `内存缓存` 和 `磁盘缓存`
    - 一般来说, 对于大文件, 大概率不会丢在内存中, 反之优先
    - 当前系统内存使用较高会优先丢入磁盘

## Push Cache
+ `Push Cache(推送缓存)`是HTTP/2中的内容, 当以上三种缓存都没有命中的时候, 他就会被使用。 它只在 `Session(会话)`状态中被使用, 一旦会话结束, 就会释, 并且缓存时间很短, 在Chrome中大概只有5mins左右, 同时也严格执行HTTP头中的缓存指令
+ 一般分为以下几点
    - 所有资源都能被推送, 但Safari支持较差(老版本EDGE一样)
    - 可以推送no-cache和no-store
    - 一旦连接关闭, 推送缓存就释放        + 多个页面可以使用同一个HTTP/2的连接, 也就是可以使用同一个 `Push Cache`, 主要是依赖浏览器的实现, 出于性能考虑, 浏览器会让相同域名但是不同的tab标签使用同一个HTTP连接
    - `Push Cache` 中的缓存只能被使用一次
    - 浏览器可以拒绝缓存推送
    - 可以给其他域推送缓存

## 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。

## 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。过程如下
+ 浏览器第一次发起HTTP请求, 在中间有一个叫`浏览器缓存`的位置
+ 查看在`浏览器缓存`中是否存在请求的缓存结果和缓存标识, 首次请求没有, 立即返回
+ 再次发起HTTP请求直达服务器
+ 服务器返回请求结果和缓存标识(缓存表示存储在响应头中, 比如ETag, 比如Last-modifyed)
+ 然后将该请求结果和缓存标识写入`浏览器缓存`中

## 因此可以得出如下结论
+ 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
+ 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存