# v8解释和编译

以V8为例, 来理解一段js代码是如何执行的
首先需要明白, 机器是读不懂JS代码的, 机器只能理解特定的机器码, 如果要让JS的逻辑在机器上运行, 那就必须将JS的代码翻译成机器码, 然后让机器识别他.

JS属于解释性语言, 对于解释性语言来说, 解释器会对源代码做如下分析:
+ 通过词法分析和语法分析生成AST语法树
+ 生成字节码

然后解释器根据字节码来执行程序。但是JS整个执行过程实际上比这个更加复杂

首先, 生成AST树，分两个步骤， 词法分析和语法分析

词法分析,就是将一段代码分解成一个一个的token。
比如
```
let name = 'xiaomo'
```
就会将句子分成四个部分
+ 关键字: let
+ 变量名: name
+ 赋值: =
+ 字符串: 'xiaomo'

这四个token会根据语法规则转化为AST树

生成AST之后的编译都将依靠AST树而不是源代码, 生辰AST之后, 就会执行上下文

然后就是生成字节码

就是前面说的生成AST树之后, 通过v8的解释器来生成字节码, 但是字节码并不能让机器直接运行,早期的是将AST直接转换为机器码, 但是这样占用内存太大执行速度太慢了, 引发了严重的内存占用问题, 最终放弃了这样的实现方式

字节码是一种比机器码轻量很多的代码, 介于AST和机器码之间, 与特定类型的机器码无关, 字节码需要通过解释器转换为机器码再来执行

现在就不用一次将字节码转换为机器码去执行了， 而是解释器逐行执行字节码转换机器码来执行, 省去了生成二进制文件的操作, 大大降低了内存的压力

在字节码的执行过程中, 如果发现一段字节码重复出现, 那么就会将这段字节码编译成机器码, 然后存储起来, 执行编译的工具就是v8的编译器，因此JS也不是完全的解释性语言。这段字节码叫做`热点代码`, 再这样的机制下, 执行的越久, 他的热点代码就越多, 执行速度也就越快, 这也是为什么在v8上运行js, 比python这类解释性语言, 还要快

总的来说就是:
+ 现将代码通过解释器的词法分析和语法分析生成AST树
+ 然后将AST树转换为字节码
+ 逐行执行字节码，遇到经常出现的字节码就启动编译器编译成机器码存储起来，下一次遇到就直接使用用以优化执行效率